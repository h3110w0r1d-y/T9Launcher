# 40KB汉字转拼音库是如何炼成的

原始拼音库长这样（298,156字节）：

```text
3007 [ling2]
4E00 [yi1,yi4,yi2]
4E01 [ding1,zheng1]
4E02 [kao3,qiao3,yu2]
...
9FA2 [he2]
9FA3 [jue2]
9FA4 [xie2]
9FA5 [yu4]
```

由于软件只需要获取拼音，不需要音调，所以可以把音调删除。删除音调后，有一部分多音字的拼音就重复了，进行去重。

除了第一个字`〇`，剩下的 Unicode 从 0x4E00 到 0x9FA5 都是连续的，所以第一个字可以直接特殊处理，硬编码到代码中，单独判断。

然后可以把 Unicode 删除，只需要知道开始的 Unicode 是 0x4E00，在代码中处理时加上这个偏移量就可以。

中括号也没必要，拼音库就变成了这样（111,210字节）：

```text
yi
ding,zheng
kao,qiao,yu
qi
...
he
jue
xie
yu
```

继续压缩，可以把所有的拼音提取出来，做成一个表，拼音库里的拼音就可以全部换成对应到拼音表中的序号。

拼音表提取出来如下，共412个（1,740字节）：

```text
yi
ding
zheng
kao
...
fiao
shei
zhei
eng
```

那就可以把拼音库中的拼音替换成从0-411的数字。但是在替换之前还可以再优化一下拼音表，按照拼音的出现频率排一下序，就可以保证出现频率最高的前10个拼音使用0-9替换，只占用一个字节。

优化完成后拼音表如下（1,740字节）：

```text
yi
ji
yu
xi
...
dia
eng
fiao
ng
```

拼音库如下（90,998字节）：

```text
0
210,106
298,47,2
7
...
39
35
20
2
```

由于软件最终匹配的是数字，所以不如将拼音提前转换成数字，这样还可以缩小一下拼音表，比如`ni`和`mi`转成9键数字都是`64`。

转换完成后的拼音表如下，共218个（945字节）：

```text
2
22
224
226
...
9826
983
984
986
```

既然拼音表小于256了，那就可以直接用一个字节表示在拼音表中的位置，前面拼音库中的逗号分隔符也可以删除，换行符换成`0xff`

拼音库变成了如下格式（47,899字节）：

| Offset | 0    | 1      | 2    | 3    | 4      | ... |
|--------|------|--------|------|------|--------|-----|
| Byte   | 0x00 | `0xFF` | 0x02 | 0x03 | `0xFF` | ... |

拼音库中大部分都不是多音字，筛选了一下，总共20,902个字，多音字共有6,095个音。

也就是说为了存储 6,095 个多音字，导致多占用了 20,902 个 `0xFF`。

那可以尝试把多音字单独存储，先把每个字的第一个音用一个字节排列。

由于字符总数是固定的，可以把多音字的数据放在最后，在固定的偏移量之后是多音字数据。

最终优化完之后的拼音库结构如下（39,187字节）：

| Offset | 0    | 1    | 2    | 3    | ... | 20901 | 20902-20903      | 20904 | 20905-20906      | 20907 | ... |
|--------|------|------|------|------|-----|-------|------------------|-------|------------------|-------|-----|
| Byte   | 0x01 | 0x23 | 0x45 | 0x67 | ... | 0x89  | 0x4Exx (Unicode) | 0xA1  | 0x4Exx (Unicode) | 0xB2  | ... |

加上拼音表的945字节，总共40,132字节，39.2KB

[解析代码](app/src/main/java/com/h3110w0r1d/t9launcher/utils/PinyinUtil.kt)
